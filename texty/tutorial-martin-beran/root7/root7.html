<HTML>
<HEAD>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-2">
</HEAD>

<BODY>
<H1>Programování pro X Window System (7)</H1>

<B>Martin Beran</B>
<EM>&lt;<A href="mailto:beran@ms.mff.cuni.cz">beran@ms.mff.cuni.cz</A>&gt;</EM>

<H2>Qt</H2>

<P>V pøedchozích èláncích jsme probrali toolkit GTK+. Nyní se budeme vìnovat
druhému slíbenému toolkitu &ndash; Qt. Nebudeme se pou¹tìt do takových
podrobností, jako u&nbsp;GTK+, proto¾e Qt v&nbsp;mnoha ohledech funguje
obdobnì jako GTK+ a navíc je velmi dobøe dokumentované. Není problém nauèit se
pou¾ívat Qt pro psaní aplikací s&nbsp;pomocí dokumentace dodávané
s&nbsp;toolkitem, která obsahuje tutoriály, vysvìtlení principù, na nich¾ je
toolkit postaven, referenèní pøíruèku a návody k&nbsp;pou¾ití doplòkových
nástrojù (Qt Designer, qmake, apod.). Dokumentace je ve formátu HTML a lze ji
prohlí¾et buï v&nbsp;libovolném webovém browseru, nebo pomocí aplikace Qt
Assistant, která je souèástí toolkitu.

<P>Toolkit Qt je multiplatformní, dostupný pro Unix (X11), Mac OS X, embedded
Linux, a MS Windows. Je¹tì více ne¾ GTK+ skrývá detaily okenního systému, nad
ním¾ bì¾í. Qt je objektovì orientované a napsané v&nbsp;C++ roz¹íøeném o&nbsp;mechanismy
definice signálù a slotù, dynamické identifikace typù a properties. Roz¹íøení
jsou implementována pomocí maker a preprocesoru <TT>moc</TT> (Meta Object
Compiler). Existují i rozhraní pro pou¾ití Qt z&nbsp;jiných jazykù: Perlu (PerlQt)
a Pythonu (PyQt). Pøi pøípravì tohoto èlánku jsem vycházel z&nbsp;verze toolkitu
3.1. Aktuální verze je 3.3.2, nicménì k&nbsp;rozdílùm mezi tìmito verzemi se ani
nedostaneme. Pokud chceme Qt aplikaci doplnit o&nbsp;skriptování, je mo¾né pou¾ít
nástroj <EM>QSA (Qt Script for Applications)</EM>, zalo¾ený na jazyce
ECMAScript.

<P>Toolkit Qt je dostupný volitelnì pod komerèní licencí pro vývoj
closed-source softwaru nebo pod GPL, popø. QPL (Qt Public License) pro vývoj
free softwaru. Podobnì duální licencování má i QSA.

<H2>Hello World</H2>

<P>Seznamování s&nbsp;toolkitem Qt zaèneme triviálním programem, který zobrazí
okno s&nbsp;tlaèítkem. Po zavøení okna program skonèí. Tlaèítko lze stisknout,
ale nic nedìlá. Celý zdrojový kód
programu je v&nbsp;souboru <A href="qthello.cpp">qthello.cpp</A>.

<P>Hlavièkové soubory Qt jsou rozdìlené podle jednotlivých tøíd. Nìkdy je
skupina funkènì svázaných tøíd definovaná v&nbsp;jednom souboru, ale obvykle má
ka¾dá tøída samostatný hlavièkový soubor. V&nbsp;na¹em prvním programu budeme
pou¾ívat tøídy <TT>QApplication</TT> a <TT>QPushButton</TT>. 
<PRE>
#include &lt;qapplication.h&gt;
#include &lt;qpushbutton.h&gt;
</PRE>

<P>Ka¾dý program má právì jednu instanci tøídy <TT>QApplication</TT>. Ta
implementuje cyklus zpracování událostí, inicializaci, závìreèný úklid a
zpracování globálních nastavení platných pro celou aplikaci. Konstruktor
dostává argumenty funkce <TT>main</TT> a odebere z&nbsp;nich argumenty urèené pro
Qt, napø. <TT>-style</TT>, <TT>-display</TT> nebo <TT>-name</TT>. Kompletní
seznam je uveden v&nbsp;dokumentaci tøídy <TT>QApplication</TT>.
<PRE>
QApplication app(argc, argv);
</PRE>

<P>Po inicializaci aplikaèního objektu mù¾eme vytváøet widgety. Ná¹ jednoduchý
program bude mít jediný widget &ndash; tlaèítko.
<PRE>
QPushButton hello("Hello world!", 0);
</PRE>
Konstruktor má tøi parametry: nápis na tlaèítku, rodièovský widget a jméno
widgetu. Zde je tlaèítko top-level widget, proto nemá rodièe. Jméno widgetu se
nezobrazuje, je to interní pojmenování. Pøíli¹ se nepou¾ívá, proto má tento
parametr implicitní hodnotu 0. Dá se pou¾ít pro nalezení objektu
podle jména (metody <TT>QObject::child</TT> a <TT>QObject::queryList</TT>) a
pro ladìní (metoda <TT>QObject::dumpObjectTree</TT>). V&nbsp;GTK+ je pro top-level
okna vyhrazena speciální tøída <TT>GtkWindow</TT>. V&nbsp;Qt mù¾e být libovolný
widget top-level. Tlaèítko nastavíme jako hlavní widget aplikace. Tím
zajistíme, ¾e pøi zavøení okna s&nbsp;tlaèítkem program skonèí.
<PRE>
app.setMainWidget(&amp;hello);
</PRE>
Ka¾dý widget je potøeba zobrazit, jinak by sice existoval jako objekt
v&nbsp;pamìti, ale nebyl by vidìt. Pøi zobrazení widgetu se zobrazí i v¹ichni jeho
potomci.
<PRE>
hello.show();
</PRE>

<P>Po vytvoøení a zobrazení widgetù a dokonèení ostatních inicializaèních akcí
je èas nastartovat zpracování událostí.
<PRE>
return app.exec();
</PRE>
Zpracování událostí skonèí zavøením hlavního widgetu nebo voláním
<TT>QApplication::quit()</TT> èi <TT>QApplication::exit</TT>. Metoda
<TT>QApplication::exec</TT> pak vrátí návratový kód pou¾itelný jako návratový
kód programu.

<H2>Vytvoøení spustitelného programu</H2>

<P>Qt obsahuje utilitu <TT>qmake</TT>, která umí automaticky vygenerovat
kompletní <TT>Makefile</TT>. Její pou¾ití je pohodlnìj¹í, ne¾ psát
<TT>Makefile</TT> ruènì. Dal¹í mo¾nost pøedstavují programy <TT>autoconf</TT>
a <TT>automake</TT>, které pou¾ívá napø. projekt KDE. Pøed spu¹tìním
<TT>qmake</TT> je nutné nastavit environmentové promìnné <TT>QTDIR</TT>
(adresáø, kde je instalované Qt, napø. <TT>/usr/X11R6</TT>) a
<TT>QMAKESPEC</TT> (kombinace platformy a kompilátoru, napø.
<TT>freebsd-g++</TT>). Následující postup se skládá z&nbsp;pìti krokù:
<OL>
<LI>Vytvoøíme adresáø pojmenovaný stejnì, jako se bude jmenovat program.
V&nbsp;na¹em pøípadì to bude <TT>qthello</TT>. Do adresáøe ulo¾íme ve¹keré zdrojové
soubory programy. My máme pouze soubor <TT>qthello.cpp</TT>.
<LI>Pøepneme se do adresáøe (<TT>cd&nbsp;qthello</TT>) a pøíkazem
<TT>qmake&nbsp;-project</TT> vygenerujeme projektový soubor. V&nbsp;nìm jsou
informace, je¾ <TT>qmake</TT> pou¾ívá pøi generování <TT>Makefile</TT>.
<LI>Projektový soubor mù¾eme upravit textovým editorem. V&nbsp;dokumentaci Qt je
podrobnì popsáno, co v¹echno mù¾eme do tohoto souboru napsat.
<LI>Vygenerujeme <TT>Makefile</TT> pøíkazem <TT>qmake</TT>.
<LI>Spustíme <TT>make</TT>.
</OL>

<H2>Signály, sloty a události</H2>

<P><EM>Signály</EM> a <EM>události</EM> u¾ známe z&nbsp;GTK+. <EM>Slot</EM> je jen
jiný název pro handler signálu. V&nbsp;GTK+ se události pøekládají na signály a dál
se zpracovávají pomocí handlerù signálù. Qt pou¾ívá signály a události jako
dva oddìlené mechanismy pro komunikaci mezi objekty v&nbsp;programu, resp. mezi
programem a okolím.

<P>Ka¾dá tøída odvozená z&nbsp;<TT>QObject</TT> má definované mno¾iny signálù a
slotù. Signály i sloty jsou speciální metody. Mohou mít parametry, ale v¾dy
mají návratový typ <TT>void</TT>. Objekt vygeneruje signál pomocí
<PRE>
emit <EM>signál(argumenty);</EM>
</PRE>
kdy¾ se s&nbsp;ním stane nìco, co by mohlo zajímat i jiné objekty &ndash; napø.
u¾ivatel vybere polo¾ku z&nbsp;menu. Qt následnì zavolá v¹echny sloty, které
jsou k&nbsp;signálu pøipojeny. Ná¹ triviální program <TT>qthello</TT> mù¾eme
upravit, aby po stisku tlaèítka skonèil, pøipojením slotu
<TT>QApplication::quit</TT> k&nbsp;signálu <TT>QPushButton::clicked</TT>.
<PRE>
QObject::connect(&amp;hello, SIGNAL(clicked()), &amp;app, SLOT(quit()));
</PRE>
Stejnì jako v&nbsp;GTK+ fungují signály a sloty synchronnì, tj. sloty se volají
okam¾itì po emitování signálu a <TT>emit</TT> se vrátí, teprve a¾ skonèí
poslední slot. Výhoda oproti GTK+ je v&nbsp;tom, ¾e pøi napojování Qt kontroluje,
zda signál a slot mají shodný poèet a typy parametrù. Pøipojený slot lze od
signálu opìt odpojit pomocí metody <TT>QObject::disconnect</TT>.

<P>Události jsou generované okenním systémem (napø. <TT>QMouseEvent</TT>),
èasovaèem (<TT>QTimerEvent</TT>) nebo aktivitou na soketu (interní události
pou¾ité v&nbsp;implementaci <TT>QSocketNotifier</TT>). Události si mohou posílat
mezi sebou i objekty v&nbsp;rámci programu. Pro tento úèel je vyhrazen typ
<TT>QCustomEvent</TT>, ale lze pou¾ít i libovolný jiný typ. Kdy¾ objekt
dostane událost, volá se nejprve metoda <TT>event</TT>. Ta pøedá událost
k&nbsp;dal¹ímu zpracování specifické metodì podle typu události, napø.
<TT>paintEvent</TT> pro událost <TT>QPaintEvent</TT>. Kdy¾ widget odmítne
voláním metody <TT>ignore</TT> událost pocházející z&nbsp;klávesnice nebo z&nbsp;my¹i
(<TT>QKeyEvent</TT>, <TT>QMouseEvent</TT>), bude se událost propagovat do
rodièovského widgetu. Objekt se mù¾e pomocí
<TT>QObject::installEventFilter</TT> zaregistrovat jako filtr (<EM>event
filter</EM>) pro nìjaký jiný objekt. Filtr dostává v¹echny události
urèené pro druhý objekt døív ne¾ on. Jestli¾e potøebujeme odchytávat úplnì
v¹echny události v&nbsp;programu, lze toho dosáhnout instalací filtru na aplikaèní
objekt <TT>QApplication</TT>. Filtry událostí pou¾ívá v&nbsp;Qt napø. tøída
<TT>QAccel</TT>, která odchytává kombinace kláves definované jako
akcelerátory. Události se zpracovávají asynchronnì. Ka¾dá událost je ulo¾ena
do fronty, odkud ji nìkdy pozdìji vybere cyklus zpracování událostí
<TT>QApplication::exec</TT>. Do fronty se dá pøidat libovolná událost voláním
<TT>QApplication::postEvent</TT>. Pøi pou¾ití pro komunikaci uvnitø programu
lze s&nbsp;událostmi pracovat i synchronnì. Metoda <TT>QApplication::sendEvent</TT>
volá pøímo handler události v&nbsp;cílovém widgetu.

<H2>Správa pamìti</H2>

<P>Qt pou¾ívá velmi jednoduchý, nicménì dobøe fungující model správy pamìti.
Objekty tøíd odvozených z&nbsp;<TT>QObject</TT> jsou organizovány do stromových
struktur. Pøi vytvoøení nového objektu se zadává jeho rodiè jako parametr
konstruktoru. Kdy¾ je 0, vytvoøí se koøen nového stromu. Pøi zru¹ení objektu
se Qt postará o&nbsp;automatické zru¹ení v¹ech jeho potomkù ve stromì objektù. Ve
tøídì <TT>QObject</TT> jsou definovány metody pro manipulaci se stromy
objektù. Metoda <TT>objectTrees</TT> vrací seznam koøenù v¹ech existujících
stromù. Rodièovský a synovské objekty se dají zjistit voláním metod
<TT>parent</TT> a <TT>children</TT>. Ke zmìnì stromu slou¾í metody
<TT>insertChild</TT> a <TT>removeChild</TT>.

<P>Widgety, tj. objekty odvozené z&nbsp;tøídy <TT>QWidget</TT> navíc vytváøejí
stromy widgetù. Ty urèují, jak budou jednotlivé widgety do sebe vnoøeny na
obrazovce. Koøeny stromù widgetù jsou top-level okna. Obvykle strom widgetù
koresponduje se stromem objektù, tak¾e pøi zru¹ení widgetu se automaticky
zru¹í v¹echny widgety, které jsou v&nbsp;nìm vizuálnì obsa¾eny. Pøi vytvoøení
objektu se rodiè zadaný jako parametr konstruktoru pou¾ije pro zapojení jak do
stromu objektù, tak i do stromu widgetù. Zmìny ve stromì widgetù je mo¾né
provádìt metodou <TT>QWidget::reparent</TT>. Je tøeba dávat si pozor na to, ¾e
pøesun widgetu v&nbsp;rámci stromù objektù nemìní pozici widgetu ve stromì widgetù.
Pokud má být zachována korespondence obou struktur, je nutné spolu
s&nbsp;<TT>QObject::insertChild</TT> nebo <TT>QObject::removeChild</TT> volat také
<TT>QWidget::reparent</TT>.

<P>Pøi zru¹ení objektu mohou na rùzných místech programu zbýt ukazatele na ji¾
neexistující objekt. Jejich dereferencování typicky zpùsobí havárii programu.
Qt proto definuje ¹ablonu <TT>QGuardedPtr</TT>, co¾ je ukazatel, který se
automaticky nastaví na 0 pøi zru¹ení objektu, na nìj¾ ukazuje.

<P>Programátoøi pou¾ívající jazyk C znají dobøe problémy s&nbsp;rozhodováním, kdo
je vlastníkem nìjaké datové struktury a mìl by se postarat o&nbsp;její dealokaci.
Napø. pøi pøedávání øetìzce &ndash; parametru typu <TT>char&nbsp;*</TT>
&ndash; do funkce musíme vìdìt, zda si funkce udìlá kopii øetìzce nebo ne.
A&nbsp;kdy¾ ne, zda funkce øetìzec dealokuje nebo zda ho má dealokovat volající. 
V&nbsp;grafické aplikaci je mnoho datových struktur s&nbsp;podobnými problémy: obrázky,
fonty, kurzory, apod. GTK+ øe¹í problém s&nbsp;tím, kdo a kdy má objekt zru¹it,
pomocí poèítání referencí. Tím ale není vyøe¹en jiný problém &ndash; èasto
bychom chtìli pøedávat parametry funkcí hodnotou, aby následnì funkce i
volající mohly datovou strukturu mìnit a zmìny provedené uvnitø funkce se
neprojevily vnì a naopak. Jen¾e datové struktury jako jsou pixmapy mohou být
hodnì velké a jejich kopírování je drahá operace. Pokud funkce ani volající
nebudou následnì hodnotu mìnit, bylo kopírování zbyteèné. Kdy¾ se naopak
parametr pøedává odkazem (resp. pomocí ukazatele), nekopíruje se datová
struktura pøi volání funkce, ale musíme mít na pamìti, ¾e kdy¾ ji chceme
zmìnit, musíme si nejdøív udìlat kopii.

<P>Qt odstraòuje oba problémy pomocí datových struktur s&nbsp;implicitnì
sdílenými daty. Objekty <TT>QString</TT>, <TT>QBitmap</TT>, <TT>QPixmap</TT>,
<TT>QCursor</TT>, apod. jsou ve skuteènosti velmi malé struktury, které
obsahují ukazatel na data ulo¾ená v&nbsp;samostatnì alokovaném bloku pamìti.
Pou¾ívá se zde poèítání referencí a copy-on-write. U&nbsp;dat je poznamenáno,
kolik objektù je pou¾ívá. Kdy¾ tento poèet klesne na 0, pamì» s&nbsp;daty je
uvolnìna. Jestli¾e je poèet odkazù vìt¹í ne¾ jedna a nìkterý objekt chce data
zmìnit, nejprve si automaticky vytvoøí privátní kopii a dat zmìna se provede
v&nbsp;kopii. V&nbsp;Qt je tedy mo¾né pøedávat napø. øetìzce (typu
<TT>QString</TT>) hodnotou bez obav, ¾e bude program zpomalen zbyteèným
kopírováním.

<P>V instancích ¹ablony <TT>QMemArray</TT> a ve tøídách <TT>QImage</TT> a
<TT>QMovie</TT> se pou¾ívá explicitní sdílení dat. To znamená, ¾e kopie
objektu bude s&nbsp;pùvodním objektem sdílet data, ale nefunguje copy-on-write.
Zmìnu provedenou prostøednictvím jednoho objektu uvidí v¹echny objekty
pou¾ívající stejná data. Objekt se mù¾e odpojit od sdílené kopie a vytvoøit
si privátní kopii dat voláním metody <TT>detach</TT> nebo <TT>copy</TT>.
</BODY>
</HTML>
