<HTML>
<HEAD>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-2">
</HEAD>

<BODY>
<H1>Programování pro X Window System (5)</H1>

<B>Martin Beran</B>
<EM>&lt;<A href="mailto:beran@ms.mff.cuni.cz">beran@ms.mff.cuni.cz</A>&gt;</EM>

<H2>Knihovna GLib</H2>

<P>Knihovna GLib obsahuje rùzné u¾iteèné funkce a datové struktury. Není
svázána s&nbsp;toolkitem GTK+, dá se pou¾ívat i samostatnì. GLib poskytuje náhradu
pro nìkteré standardní typy jazyka C, definuje napø. <TT>gchar</TT>,
<TT>gint</TT>, <TT>gpointer</TT>, <TT>guint16</TT>... Souèástí GLib jsou i
redefinice standardních knihovních funkcí, jako jsou funkce pro manipulaci
s&nbsp;nulou ukonèenými øetìzci ve stylu jazyka C (<TT>g_snprintf</TT>,
<TT>g_strcasecmp</TT>, <TT>g_strdup</TT>, atd.). Dùvodem existence této èásti
GLib je snaha o&nbsp;pøenositelnost. V&nbsp;moderních unixových systémech u¾ obvykle
knihovny obsahují v¹e, co by podle standardù obsahovat mìly, a definice toho
samého pod jiným jménem se mù¾e zdát nadbyteèná. Nicménì v&nbsp;dobì, kdy GLib a
GTK+ zaèaly vznikat, nebyly systémové knihovny na rùzných verzích Unixu
dostateènì kompatibilní. Knihovna GLib navíc funguje i na jiných platformách,
jako MS Windows.

<P>Druhá èást GLib obsahuje pomocné funkce a makra. Jsou zde makra pro
pøetypování mezi èísly a ukazateli (<TT>GINT_TO_POINTER</TT>,
<TT>GPOINTER_TO_INT</TT>). Ladìní programù usnadòují makra
<TT>g_return_if_fail</TT> (pro funkce s&nbsp;návratovým typem <TT>void</TT>) a
<TT>g_return_val_if_fail</TT> (pro funkce vracející hodnotu). Jejich typické
pou¾ití je kontrola parametrù pøi vstupu do funkce. Pokud není splnìná
podmínka zadaná jako parametr makra, vypí¹e se chybové hlá¹ení a provede se
návrat z&nbsp;aktuální funkce. Dal¹í ladicí makra jsou <TT>g_assert</TT> a
<TT>g_assert_not_reached</TT>. GLib má vlastní funkce pro alokace pamìti,
které ukonèí bìh programu, pokud nelze alokaci provést: <TT>g_malloc</TT> je
obdoba standardní funkce <TT>malloc</TT> a <TT>g_malloc0</TT> navíc
naalokovanou pamì» vynuluje (jako <TT>calloc</TT>). Pro dealokaci slou¾í
funkce <TT>g_free</TT>.

<P>Ve tøetí èásti knihovny GLib jsou definovány datové struktury podobné STL
kontejnerùm v&nbsp;C++. K&nbsp;dispozici jsou øetìzce <TT>GString</TT>, které
automaticky zvìt¹ují datový buffer pøi prodlu¾ování øetìzce, jednosmìrné
(<TT>GSList</TT>) a obousmìrné (<TT>GList</TT>) spojové seznamy, vyvá¾ené
binární stromy (<TT>GTree</TT>), n-ární stromy (<TT>GNode</TT>), ha¹ovací
tabulky (<TT>GHashTable</TT>), automaticky se zvìt¹ující pole
(<TT>GArray</TT>), aj.

<P>Poslední skupina typù a funkcí v&nbsp;GLib poskytuje prostøedky, nad kterými
je postavena infrastruktura toolkitu GTK+. Struktura <TT>GHookList</TT>
reprezentuje seznam callback funkcí. V&nbsp;GTK+ se pou¾ívá v&nbsp;mechanismu registrace
a volání handlerù signálù. Z&nbsp;generického cyklu pro zpracování událostí je
odvozena funkce <TT>gtk_main</TT>. Lexikální analyzátor se pou¾ívá pøi
zpracování resource souborù definujících styly widgetù.

<H2>Timeouty, I/O</H2>

<P>Zatím jsme uva¾ovali grafické aplikace, které komunikují pouze
s&nbsp;u¾ivatelem. Program èeká v&nbsp;<TT>gtk_main</TT> na událost od X
serveru, zpracuje ji a vrátí se zpìt do <TT>gtk_main</TT>. Kdy¾ není ¾ádná
událost k&nbsp;dispozici, program nic nedìlá. Takový model ale není v¾dy
postaèující. Nìkdy je potøeba provádìt urèité akce periodicky. Napø. pøi
zobrazování animace se v&nbsp;pravidelných intervalech pøekresluje obsah
widgetu. Pomocí <TT>gtk_timeout_add</TT> lze zaregistrovat funkci, která bude
volána po uplynutí zadaného poètu milisekund. Kdy¾ funkce vrátí <TT>TRUE</TT>,
bude se volat znovu za stejnou dobu. Návratová hodnota <TT>FALSE</TT> nebo
volání <TT>gtk_timeout_remove</TT> funkci odregistruje, tak¾e se u¾ nebude
provádìt. Nìkdy potøebujeme urèitou funkci volat tak èasto, jak je to mo¾né,
napø. pokud ka¾dé zavolání provede èást nìjakého dlouhotrvajícího výpoètu.
K&nbsp;tomuto úèelu se dají vyu¾ít funkce <TT>gtk_idle_add</TT> a
<TT>gtk_idle_remove</TT>, které fungují podobnì jako timeouty, ale
registrovaná funkce se bude volat v¾dy, kdy¾ ve frontì neèeká na zpracování
¾ádná událost.

<P>Pokud program potøebuje èíst nebo zapisovat do souboru, zaøízení nebo
soketu, je potøeba zajistit správné kódování dat a nezablokovat u¾ivatelské
rozhraní pøi èekání na data. Oba problémy v&nbsp;GTK+, resp. GLib, øe¹í I/O
kanály (typ <TT>GIOChannel</TT>). Kdy¾ máme otevøený deskriptor, voláním
funkce <TT>g_io_channel_unix_new</TT> k&nbsp;nìmu vytvoøíme kanál. Pomocí
<TT>g_io_channel_set_encoding</TT> se dá nastavit kódování dat v&nbsp;kanálu.
Implicitnì se pou¾ívá UTF-8. Jestli¾e nechceme, aby kanál do dat jakkoliv
zasahoval, nastavíme kódování na <TT>NULL</TT>. I/O kanály pou¾ívají poèítání
referencí. Kanál se zru¹í, kdy¾ <TT>g_io_channel_unref</TT> sní¾í poèet
referencí na nulu. Volání <TT>g_io_add_watch</TT> zaregistruje pro zadaný
kanál handler, který se bude volat, kdy¾ na kanálu nastane po¾adovaná událost:
je k&nbsp;dispozici aspoò 1 bajt dat ke ètení (<TT>G_IO_IN</TT>) nebo lze
aspoò 1 bajt zapsat (<TT>G_IO_OUT</TT>). Èekání na kanálech je souèástí
<TT>gtk_main</TT>, tak¾e neblokuje fungování u¾ivatelského rozhraní.

<H2>Konfigurace vzhledu widgetù</H2>

<P>Styl, jakým se zobrazují widgety, lze konfigurovat pomocí textových
<EM>resource souborù</EM>. V&nbsp;rámci stylu je definován font pou¾ívaný widgetem,
barvy pozadí a popøedí, pøípadnì pixmapa na pozadí. V&nbsp;resource souboru se dají
také pøiøazovat signály ke klávesám a tak nastavit, ¾e stisk urèité klávesy
vyvolá nìjakou funkci v&nbsp;programu. Funkce <TT>gtk_init</TT> naèítá soubory
<TT>SYSCONFDIR/gtk-2.0/gtkrc</TT> (kde <TT>SYSCONFDIR</TT> je adresáø
nastavený pøi instalaci toolkitu) a <TT>$HOME/.gtkrc-2.0</TT>. Navíc ète je¹tì
soubor specifický pro aktuální locale, napø. <TT>$HOME/.gtkrc-2.0.cs_CZ</TT>.
Dal¹í resource soubory je mo¾né naèíst voláním funkce <TT>gtk_rc_parse</TT>.

<P>V resource souboru jsou oddìlené definice stylù a mapování kláves od jejich
pøiøazení jednotlivým widgetùm. Definice stylu mù¾e vypadat takto:
<PRE>
style "my-menu"
{
  font="-*-arial-medium-r-*-*-*-120-*-*-p-*-iso8859-2"
  bg[PRELIGHT] = { 0.0, 0.0, 0.6 }
  fg[PRELIGHT] = { 1.0, 1.0, 1.0 }
}
</PRE>
Ka¾dý styl má své jméno. Font se nastavuje buï pomocí <TT>font</TT> a
<TT>fontset</TT> (X-ová jména fontù), nebo pomocí <TT>font_name</TT> (jména
fontù ve tvaru pro knihovnu Pango). Tato poslední varianta má nejvy¹¹í
prioritu. Barvy se definují samostatnì pro rùzné stavy widgetu:
<UL>
<LI><TT>NORMAL</TT> ... normální stav widgetu
<LI><TT>ACTIVE</TT> ... aktivovaný widget, napø. kliknutím my¹i
<LI><TT>PRELIGHT</TT> ... tlaèítko nebo polo¾ka menu, na které je kurzor my¹i
<LI><TT>SELECTED</TT> ... vybrané polo¾ky v&nbsp;seznamu, oznaèený text v&nbsp;editaèním
øádku, apod.
<LI><TT>INSENSITIVE</TT> ... widgety, které mají vypnutou interakci
s&nbsp;u¾ivatelem
</UL>

<P>Pokud chceme umo¾nit nastavovat styl pro konkrétní widget, mìli bychom
widget pojmenovat pomocí <TT>gtk_widget_set_name</TT>. Následnì mu mù¾eme
v&nbsp;resource souboru pøiøadit styl takto:
<PRE>
widget "mywindow.*.GtkMenuItem" style "my-menu"
</PRE>
Jméno widgetu v&nbsp;resource souboru zadáváme ve formì posloupnosti jmen widgetù
oddìlených teèkou, která zaèíná v&nbsp;top-level oknì a konèí ve widgetu, jeho¾
styl nastavujeme. Pokud nemá nìkterý widget v&nbsp;posloupnosti nastavené jméno,
pou¾ívá se jméno jeho tøídy (v&nbsp;na¹em pøíkladu je to pøípad
<TT>GtkMenuItem</TT>). V&nbsp;cestì od top-level okna k&nbsp;widgetu mù¾eme pou¾ít
wildcardy &bdquo;<TT>*</TT>&ldquo; (zastupuje libovolnou posloupnost znakù) a
&bdquo;<TT>?</TT>&ldquo; (zastupuje jeden znak).

<P>Místo nastavení konkrétního widgetu lze urèit styl pro v¹echny widgety
z&nbsp;nìjaké tøídy:
<PRE>
widget_class "GtkWindow.*.GtkMenuItem style "my-menu"
</PRE>
Opìt se zadává posloupnost jmen zaèínající top-level oknem, ale tentokrát to
jsou jména tøíd. Poslední variantou je nastavení stylu pro úplnì v¹echny
widgety v&nbsp;aplikaci, které patøí do urèité tøídy nebo do nìkteré z&nbsp;ní odvozené
tøídy:
<PRE>
class "GtkMenuItem" style "my-menu"
</PRE>

<P>Polo¾ky ze v¹ech naètených resource souborù, je¾ odpovídají urèitému
widgetu, se skládají dohromady tak, ¾e nejvy¹¹í prioritu mají polo¾ky
<TT>widget</TT>, následuje <TT>widget_class</TT> a nejmen¹í prioritu má
<TT>class</TT>. Mezi polo¾kami stejného typu mají pøednost ty, které byly
naèteny pozdìji.

<H2>Komunikace mezi programy</H2>

<P>Základním mechanismem komunikace mezi programy v&nbsp;GTK+ jsou <EM>výbìry
(selections)</EM>. Z&nbsp;pohledu u¾ivatele funguje výbìr velice jednodu¹e.
U¾ivatel my¹í oznaèí napø. blok textu a kliknutím prostøedním tlaèítkem ho
vlo¾í do jiného widgetu. Výbìry v&nbsp;GTK+ jsou implementovány pomocí funkcí pro
výbìry v&nbsp;Xlib. Pou¾itím standardního mechanismu výbìrù X je zaji¹tìno, ¾e
aplikace GTK+ mohou komunikovat i s&nbsp;X-ovými programy pou¾ívajícími jiné
toolkity nebo jen samotnou knihovnu Xlib. Pøenos dat probíhá prostøednictvím X
serveru, komunikující aplikace mezi sebou nemusí mít pøímé spojení. Nìkteré
widgety, jako <TT>GtkEntry</TT> nebo <TT>GtkTextView</TT>, umí pracovat
s&nbsp;výbìry ani¾ by se o&nbsp;to musel programátor starat.

<P>Obr. 1 ukazuje fungování selections na stranì zdroje i cíle pøenosu dat.
Pokud má být widget schopen poskytovat data pro výbìr, musí ka¾dý typ
(v&nbsp;terminologii X <EM>cíl &ndash; target</EM>), do nìho¾ je schopen data
konvertovat, registrovat funkcí <TT>gtk_selection_add_target</TT>. Tuto funkci
je nutné volat pro ka¾dou dvojici výbìr, cíl. Obvykle se pou¾ívá primární
výbìr <TT>GDK_PRIMARY_SELECTION</TT>. Widgety umí automaticky poskytovat cíl
<TT>"TARGETS"</TT>, co¾ nejsou data, ale seznam v¹ech cílù, které má widget
registrované. Kdy¾ u¾ivatel oznaèí vybraná data, widget si pøivlastní výbìr
voláním <TT>gtk_selection_owner_set</TT>. Pøedchozí vlastník výbìru dostane
signál <TT>"selection_clear_event"</TT>. Obvykle na nìj reaguje zru¹ením
grafického zvýraznìní vybraných dat. Vlo¾ení vybraných dat do cílového widgetu
je aktivováno akcí u¾ivatele. Proces pøenosu dat zahájí funkce
<TT>gtk_selection_convert</TT>. Zadává se po¾adovaný výbìr a cíl (typ dat).
Vlastník widgetu je o&nbsp;¾ádosti o&nbsp;data informován signálem
<TT>"selection_get"</TT>. Zareaguje na nìj ulo¾ením dat v&nbsp;po¾adovaném formátu
pomocí funkce <TT>gtk_selection_data_set</TT>. Následnì cílový widget dostane
signál <TT>"selection_received"</TT>. Pøijatá data dostane jako parametr 
handleru tohoto signálu. Komunikace je tedy asynchronní. Cílový widget po¾ádá
o&nbsp;obsah výbìru, ale neèeká na dokonèení pøenosu dat. Místo toho pokraèuje
normálnì dál ve zpracování událostí a èasem dostane data prostøednictvím
signálu.

<DIV align="center">
<P><IMG alt="selections" src="selections.png">
<P>Obr. 1: Komunikace pomocí výbìru (selection)
</DIV>

<P>GTK+ poskytuje je¹tì alternativní metodu manipulace s&nbsp;výbìry &ndash;
clipboard. Pøíslu¹né funkce mají prefix <TT>gtk_clipboard_</TT>. Typy dat
(cíle) a jména výbìrù jsou øetìzce, napø. <TT>"TARGETS"</TT>,
<TT>"STRING"</TT>, <TT>"INTEGER"</TT>. Aby se nepøená¹ely potenciálnì dlouhé
øetìzce, pou¾ívají se místo nich èíselné identifikátory &ndash;
<EM>atomy</EM>. Program, který chce pou¾ívat atom, si jej nejprve zaregistruje
voláním <TT>gdk_atom_intern</TT>. Jako parametr zadá jméno atomu &ndash;
øetìzec. Zpìt dostane atom &ndash; èíslo. Atomy jsou platné v&nbsp;rámci jednoho
spu¹tìní X serveru. Ka¾dé volání <TT>gdk_atom_intern</TT> se stejným jménem
vrátí stejný atom. Pro rùzná jména dostaneme rùzné atomy.

<P>Dal¹í zpùsob komunikace mezi programy je <EM>drag&amp;drop</EM>. Opìt
pou¾ívá standardní mechanismy X a funguje i s&nbsp;programy, které nepou¾ívají
toolkit GTK+. Schéma jeho fungování je na obr. 2.

<DIV align="center">
<P><IMG alt="drag drop" src="dragdrop.png">
<P>Obr. 2: Drag &amp;drop
</DIV>

<P>Widget, který chce být potenciálním zdrojem nebo cílem operace
drag&amp;drop, se musí registrovat pomocí funkcí <TT>gtk_drag_source_set</TT>,
resp. <TT>gtk_drag_dest_set</TT>. Jestli¾e u¾ivatel pøetáhne my¹í ikonu
reprezentující nìjaká data z&nbsp;jednoho widgetu do jiného, dostane zdrojový
widget signál <TT>"drag_data_get"</TT>. Zareaguje na nìj ulo¾ením dat pomocí
volání <TT>gtk_selection_data_set</TT>. Cílový widget dostane signál
<TT>"drag_data_received"</TT>, který má jako jeden z&nbsp;parametrù doruèená data.
Jestli¾e operace drag&amp;drop byla typu &bdquo;move&ldquo; dostane zdroj
signál <TT>"drag_data_delete"</TT> informující o&nbsp;tom, ¾e data dorazila do cíle
a na zdrojové stranì mohou být smazána.

</BODY>
</HTML>
