<HTML>
<HEAD>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-2">
</HEAD>

<BODY>
<H1>Programování pro X Window System (6)</H1>

<B>Martin Beran</B>
<EM>&lt;<A href="mailto:beran@ms.mff.cuni.cz">beran@ms.mff.cuni.cz</A>&gt;</EM>

<H2>Typy, tøídy, objekty</H2>

<P>Toolkit GTK+ má svùj vlastní typový systém, definovaný v&nbsp;knihovnì GObject.
Ka¾dý datový typ má unikátní numerický identifikátor typu (<TT>GType</TT>),
pøidìlený pøi registraci typu. V&nbsp;rámci inicializace toolkitu ve funkci
<TT>gtk_init</TT> se registrují <EM>fundamentální typy</EM>, tj. primitivní
typy jazyka C (napø. <TT>int</TT> má identifikátor <TT>G_TYPE_INT</TT>) a
<TT>G_TYPE_OBJECT</TT>, oznaèující základní objektový typ <TT>GObject</TT>.
V¹echny tøídy v&nbsp;GTK+ jsou odvozené z&nbsp;<TT>GObject</TT>. Typový systém
nepodporuje vícenásobnou dìdiènost, místo ní má interfejsy. Tøídy
nezaregistrované v&nbsp;<TT>gtk_init</TT> se automaticky registrují v&nbsp;okam¾iku
vytvoøení prvního objektu dané tøídy. Pro ka¾dou tøídu jsou definovány dvì
struktury. Struktura pro <EM>instanci</EM> obsahuje data konkrétního objektu.
Ve struktuøe pro <EM>tøídu</EM> jsou ukazatele na funkce. Je to obdoba tabulky
virtuálních metod pou¾ívané v&nbsp;C++. Ve struktuøe pro tøídu mohou být i data
tøídy (obdoba èlenù <TT>static</TT> v&nbsp;C++). Pro tento úèel se ale èastìji
pou¾ívají <TT>static</TT> promìnné definované v&nbsp;souboru <TT>.c</TT>
implementujícím tøídu. Prvním prvkem ka¾dé struktury je v¾dy struktura
bázového typu. Tím je zaji¹tìno, ¾e bude korektnì fungovat pøetypování na
pøedka. Napø. pro typ <TT>GtkButton</TT> jsou v&nbsp;souboru <TT>gtkbutton.h</TT>
definice
<PRE>
typedef struct _GtkButton GtkButton;
typedef struct _GtkButtonClass GtkButtonClass;

struct _GtkButton
{
  GtkBin bin;
  ...
};

struct _GtkButtonClass
{
  GtkBinClass parent_class;
  ...
};
</PRE>

<P>Pro ka¾dý typ widgetu <B>WIDGET</B> existuje funkce
<TT>gtk_<B>WIDGET</B>_get_type</TT>, je¾ vrací identifikátor typu. Dále je
definováno mnoho maker pro manipulaci s&nbsp;typy, napø.:
<UL>
<LI><TT>GTK_TYPE_<B>WIDGET</B></TT> ... vrací identifikátor typu pro typ
widgetù <B>WIDGET</B>
<LI><TT>GTK_<B>WIDGET</B></TT> ... pøetypuje parametr na ukazatel na objekt
<B>WIDGET</B>; typ parametru musí být <B>WIDGET</B> nebo jeho potomek, jinak
vypí¹e chybové hlá¹ení
<LI><TT>GTK_<B>WIDGET</B>_CLASS</TT> ... pøetypuje parametr na ukazatel na
strukturu tøídy pro typ <B>WIDGET</B>; kontroluje, zda parametr je struktura
pro tøídu <B>WIDGET</B> nebo pro odvozenou tøídu
<LI><TT>GTK_IS_<B>WIDGET</B></TT> ... otestuje, zda parametr je objekt typu
<B>WIDGET</B> nebo objekt odvozené tøídy
<LI><TT>GTK_IS_<B>WIDGET</B>_CLASS</TT> ... otestuje, zda parametr je
struktura tøídy pro typ <B>WIDGET</B> nebo pro odvozený typ
</UL>

<H2>Vytvoøení objektu</H2>

<P>Objekt nìjakého typu <B>WIDGET</B> se vytvoøí funkcí
<TT>gtk_<B>WIDGET</B>_new</TT>. Pro nìkteré typy widgetù existuje takových
funkcí víc. Li¹í se jménem a parametry. Napø. pro tøídu
<TT>GtkMenuItem</TT> jsou definované funkce <TT>gtk_menu_item_new</TT>,
<TT>gtk_menu_item_new_with_label</TT> a
<TT>gtk_menu_item_new_with_mnemonic</TT>. Na obr.&nbsp;1 je schematicky
znázornìn postup vytvoøení widgetu.

<DIV align="center">
<P><IMG alt="gtk_widget_new" src="widgetnew.png">
<P>Obr. 1: Vytvoøení widgetu
</DIV>

<P>Vytvoøení widgetu typu <B>WIDGET</B> zaèíná zavoláním funkce
<TT>gtk_<B>WIDGET</B>_new</TT>. Ta na zaèátku zjistí identifikátor typu
voláním <TT>gtk_<B>WIDGET</B>_get_type</TT>. Pokud je tato funkce pou¾ita
poprvé, musí zaregistrovat tøídu v&nbsp;typovém systému knihovny GObject. To udìlá
pomocí funkce <TT>g_type_register_static</TT>, které pøedá identifikátor
rodièovského typu a strukturu obsahující jméno novì registrované tøídy,
velikosti struktur pro tøídu a pro instanci a ukazatele na inicializaèní
funkce.

<P>Identifikátor typu se pøedá funkci <TT>gtk_type_new</TT>, je¾ volá
<TT>g_object_new</TT>. Tato funkce pøed vytvoøením první instance daného typu
inicializuje strukturu pro tøídu voláním <TT>g_type_class_ref</TT>,
která dále volá funkci <TT>type_class_init_Wm</TT>. Ta alokuje strukturu pro
tøídu a zkopíruje do ní &ndash; na zaèátek &ndash; strukturu rodièovské tøídy.
Jestli¾e nepostaèuje bázovou tøídu zkopírovat, lze pro tøídu definovat funkci
zaji¹»ující dal¹í inicializaci kopie bázové tøídy. Tyto inicializaèní funkce
se volají postupnì v&nbsp;celé posloupnosti bázových tøíd ve smìru od koøene
hierarchie po rodièe právì inicializované tøídy. Nakonec se provede
inicializaèní funkce tøídy, která pøedev¹ím zajistí registraci properties a
signálù.

<P>Kdy¾ je registrovaný typ a inicializována struktura pro tøídu, je mo¾né
vytvoøit instanci. Funkce <TT>gtk_type_new</TT> zavolá konstruktor definovaný
pro tøídu, její¾ objekt se vytváøí. Konstruktor nejprve spustí konstruktor
rodièovské tøídy. Konstruktor <TT>g_object_constructor</TT> spoleèného pøedka
&ndash; tøídy <TT>GObject</TT> &ndash; alokuje pamì» pro strukturu instance. Pak
zavolá postupnì inicializaèní funkce pro objekty bázových tøíd a tím
inicializuje první polo¾ku struktury objektu, která obsahuje zdìdìná data.
Nakonec se zavolá funkce pro inicializaci novì definovaných polo¾ek. Tím
volání <TT>gtk_<B>WIDGET</B>_new</TT> konèí a vrací ukazatel na novì vytvoøený
objekt.

<H2>Properties a signály</H2>

<P><EM>Properties</EM> jsou hodnoty pøiøazené objektùm a identifikované pomocí
øetìzcových klíèù. Jméno property se zadává buï samostatnì (napø.
<TT>"border_width"</TT>), nebo spolu se jménem tøídy (napø.
<TT>"GtkContainer::border_width"</TT>). Properties se dìdí. Pøi ètení nebo
nastavování hodnoty se property daného jména hledá od tøídy objektu, s&nbsp;jeho¾
property se pracuje, smìrem ke <TT>GObject</TT>. Properties se nastavují
funkcí <TT>g_object_set</TT> a ètou funkcí <TT>g_object_get</TT>. Pro nìkteré
properties existují i specializované funkce, které s&nbsp;nimi manipulují. Napø.
<TT>gtk_container_set_border_width</TT> má stejný efekt jako nastavení hodnoty
property <TT>"GtkContainer::border-width"</TT>. Funkce
<TT>g_object_class_list_properties</TT> slou¾í ke zji¹tìní jmen v¹ech
properties definovaných v&nbsp;nìjaké tøídì.

<P>Properties pøedstavují jednotné rozhraní, pøes které lze manipulovat
s&nbsp;hodnotami uvnitø objektù. Díky tomu, ¾e jména properties jsou øetìzce, dá se
manipulace s&nbsp;nimi naprogramovat i bez apriorní znalosti jmen v¹ech properties,
s&nbsp;nimi¾ se bude pracovat. To je výhodné pøi implementaci rozhraní
zpøístupòujícího GTK+ z&nbsp;nìjakého skriptovacího jazyka, nebo pro programy na
grafický interaktivní návrh GUI, jako je Glade.

<P>Properties se definují v&nbsp;inicializaèní funkci tøídy voláním funkce
<TT>g_object_class_install_property</TT>. Ve tøídì, která
definuje vlastní properties, je nutné implementovat funkce pro ètení a
nastavování properties definovaných v&nbsp;této tøídì a ukazatele na nì pøiøadit do
<TT>((GObject&nbsp;*)klass)-&gt;get_property</TT> a
<TT>((GObject&nbsp;*)klass)-&gt;set_property</TT>, kde <TT>klass</TT> je
struktura pro tøídu. Není tøeba se starat o&nbsp;zdìdìné properties, proto¾e se pro
nì automaticky volají pøíslu¹né funkce bázových tøíd. Funkce pro manipulaci
s&nbsp;properties mohou dìlat i komplexnìj¹í vìci ne¾ jen èíst èi mìnit nìjakou
datovou polo¾ku objektu. Lze si napø. pøedstavit dvojici properties, jedna
bude obsahovat ¹íøku widgetu v&nbsp;pixelech a druhá v&nbsp;milimetrech. V&nbsp;datech
objektu bude ulo¾ena pouze ¹íøka v&nbsp;pixelech. ©íøka v&nbsp;milimetrech se bude
dynamicky dopoèítávat podle rozli¹ení obrazovky. Zmìna ¹íøky navíc zpùsobí
pøekreslení widgetu.

<P>V inicializaèní funkci tøídy se definují také <EM>signály</EM>. Signály se
rovnì¾ dìdí. Pøi definici signálu funkcí <TT>g_signal_new</TT> se zadává
<UL>
<LI>jméno signálu
<LI>identifikátor typu, pro nìj¾ se signál definuje
<LI>poøadí, v&nbsp;jakém se spou¹tí defaultní handler a handlery pøipojené pomocí
<TT>g_signal_connect</TT>
<LI>offset ukazatele na defaultní handler ve struktuøe pro tøídu vzhledem
k&nbsp;zaèátku struktury
<LI>akumulátor, do nìho¾ se návratové hodnoty jednotlivých handlerù skládají,
aby bylo mo¾né získat jednu návratovou hodnotu vrácenou po zpracování v¹ech
handlerù
<LI>marshaller, tj. funkce pro pøevod pole argumentù typu <TT>GValue</TT>
(univerzální struktura, je¾ mù¾e obsahovat hodnoty rùzných typù) na seznam
parametrù funkce
<LI>typ návratové hodnoty nebo <TT>G_TYPE_NONE</TT>, pokud signál nic nevrací
<LI>poèet a typy parametrù handleru
</UL>
Vysvìtlení asi potøebuje pøedev¹ím marshaller. Pøi vygenerování signálu
&ndash; napø. funkcí <TT>g_signal_emit</TT> &ndash; se vytvoøí pole parametrù
ve formì struktur <TT>GValue</TT>. Handler ale má seznam parametrù konkrétních
typù, stejnì jako jakákoliv jiná funkce v&nbsp;jazyce C. Problém je, ¾e C
neposkytuje prostøedek pro rozdìlení pole do seznamu argumentù a volání funkce
s&nbsp;tìmito argumenty. Proto je nutné pro ka¾dou kombinaci typù parametrù
definovat marshaller, co¾ je funkce, která rozebere pole struktur
<TT>GValue</TT>, pøedìlá ho na seznam parametrù, zavolá funkci s&nbsp;tìmito
parametry a vrátí návratovou hodnotu volané funkce. GTK+ obsahuje marshallery
pro mnoho kombinací typù parametrù. Pokud definujeme signál s&nbsp;parametry, pro
nì¾ není v&nbsp;GTK+ marshaller, musíme definovat pøíslu¹ný marshaller sami.

<H2>Dùle¾ité metody widgetù</H2>

<P>Zru¹ení widgetu zaèíná voláním <TT>g_object_unref</TT> nebo
<TT>gtk_widget_destroy</TT>. Vlastní destrukce widgetu je rozdìlena do tøí
fází. Metoda <TT>dispose</TT> zru¹í X okno widgetu a vyjme widget
z&nbsp;rodièovského kontejneru. Pak emituje signál <TT>"destroy"</TT> a tím zahájí
druhou fázi. Handler <TT>destroy</TT> oznaèí objekt jako
&bdquo;nepou¾itelný&ldquo; a uvolní s&nbsp;ním asociované systémové zdroje vyjma
samotné struktury instance. V&nbsp;pøípadì, ¾e widget je kontejner, zru¹í synovské
widgety. Mìlo by v¹ak jít stále volat ve¹keré veøejné metody (proto¾e na
objekt stále mohou existovat platné reference), ty sice u¾ nebudou nic dìlat,
nicménì program nehavaruje. Poslední fáze &ndash; <TT>finalize</TT> &ndash; se
provede, teprve kdy¾ poèet referencí na objekt klesne na nulu. Uvolní se
struktura instance a tím se definitivnì dokonèí zru¹ení widgetu.

<P>Metoda <TT>realize</TT> ve tøídì <TT>GtkWidget</TT> funguje pouze pro
widgety, které nemají vlastní GDK/X okno. Pro ostatní widgety je nutno metodu
<TT>realize</TT> pøedefinovat tak, ¾e nastaví pøíznak <TT>GTK_REALIZED</TT>,
vytvoøí GDK okno voláním <TT>gdk_window_new</TT>, ukazatel na nì ulo¾í do
<TT>widget-&gt;window</TT>, k&nbsp;oknu pøidá odkaz zpìt na widget pomocí
<TT>gdk_window_set_user_data(widget-&gt;window,&nbsp;widget)</TT> a nastaví
styl widgetu voláním <TT>gtk_style_attach</TT>.

<P>Metoda <TT>unrealize</TT> odmapuje a zru¹í GDK okno widgetu (pokud widget
GDK okno má). Jestli¾e je widget kontejner, zavolá nejprve <TT>unrealize</TT>
pro v¹echny synovské widgety.

<P>Metody <TT>map</TT> a <TT>unmap</TT> nastaví, resp. zru¹í pøíznak widgetu
<TT>GTK_WIDGET_MAPPED</TT> a zobrazí/schová GDK okno
<TT>widget-&gt;window</TT>. Ne¾ se widget objeví na obrazovce, je nutné
nastavit jeho velikost s&nbsp;vyu¾itím metod <TT>size_request</TT> a
<TT>size_allocate</TT> tak, jak to bylo popsáno v&nbsp;kapitole o&nbsp;kontejnerech ve
tøetím dílu tohoto seriálu.

<P>Widget, který není jen neviditelným kontejnerem pro jiné widgety, se musí
umìt nakreslit na obrazovku. Potøeba pøekreslit widget mù¾e nastat z&nbsp;nìkolika
dùvodù. Jestli¾e se neviditelná èást okna widgetu stane viditelnou &ndash;
napø. proto¾e se pøesune nebo odmapuje okno, které ji zakrývalo &ndash;
dostane widget od X serveru událost <TT>"expose-event"</TT>. Handler události
zajistí kreslení. Nìkdy se o&nbsp;pøekreslení rozhodne samo GTK+ (pøi zmìnì
velikosti widgetu nebo pøi nastavení nové theme). Pøi zmìnì svého stavu se
widget pøekreslí sám od sebe. Obsah widgetù v&nbsp;GTK+ se kreslí s&nbsp;pou¾itím
kreslicích funkcí knihovny GDK. Je¹tì lep¹í, ne¾ kreslit pøímo pomocí GDK, je
vyu¾ít funkce z&nbsp;theme, aby vzhled widgetu ladil s&nbsp;ostatními a dal se mìnit
zmìnou theme.

<H2>Definice nové tøídy</H2>

Pro ka¾dou tøídu widgetù se vytváøí samostatná dvojice souborù
<TT>gtk<B>WIDGET</B>.h</TT> a <TT>gtk<B>WIDGET</B>.c</TT>. Je tøeba definovat
struktury pro tøídu a instanci <TT>Gtk<B>WIDGET</B>Class</TT> a
<TT>Gtk<B>WIDGET</B></TT>. Dále je nutné implementovat øadu metod pro:
<UL>
<LI>registraci typu <TT>gtk_<B>WIDGET</B>_get_type</TT>
<LI>vytvoøení instance <TT>gtk_<B>WIDGET</B>_new</TT>
<LI>inicializaci tøídy, která zajistí definování nových properties
a signálù a nastavení defaultních handlerù signálù
<LI>inicializaci instance
<LI>zru¹ení objektu <TT>dispose</TT>, <TT>destroy</TT>, <TT>finalize</TT>
<LI>realizaci a mapování <TT>realize</TT>, <TT>unrealize</TT>, <TT>map</TT>,
<TT>unmap</TT>
<LI>nastavení velikosti <TT>size_request</TT>, <TT>size_allocate</TT>
<LI>kreslení <TT>expose_event</TT>
</UL>

<DIV align="center">
<P><IMG alt="widget gtkev" src="gtkev.png">
<P>Obr. 2: Definice nového widgetu
</DIV>

<P>Ukázka definice nového widgetu <TT>GtkEv</TT> je v&nbsp;souborech
<A href="gtkev.h">gtkev.h</A> a <A href="gtkev.c">gtkev.c</A>. Tento widget má
podobnou funkci jako program <TT>xev</TT> z&nbsp;distribuce X, tj. vypisuje
informace o&nbsp;událostech, které dostává. Widget je zvlá¹tní tím, ¾e má dvì GDK
okna. Widget je pou¾it v&nbsp;programu <A href="gtk_ev_usage.c">gtk_ev_usage.c</A>.
Okno tohoto programu je na obr.&nbsp;2. Widget <TT>GtkEv</TT> je upravený
stejnojmenný widget z&nbsp;knihy Havoc Pennington: GTK+/GNOME Application
Development.

</BODY>
</HTML>
