<HTML>
<HEAD>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-2">
</HEAD>

<BODY>
<H1>Programování pro X Window System (8)</H1>

<B>Martin Beran</B>
<EM>&lt;<A href="mailto:beran@ms.mff.cuni.cz">beran@ms.mff.cuni.cz</A>&gt;</EM>

<H2>Definice nové tøídy widgetù</H2>

<P>Vytvoøit nový typ widgetu je v&nbsp;toolkitu Qt velice jednoduché. Jako základ
vybereme tøídu, která má vlastnosti co nejbli¾¹í tomu, èeho chceme dosáhnout.
Jako pøíklad si uká¾eme widget <TT>LCDRange</TT> z&nbsp;tutoriálu Qt (v&nbsp;dokumentaci
Qt je to Tutorial #1, kap. 7). Program se skládá ze tøí souborù: <A
href="lcdrange.h">lcdrange.h</A> (definice tøídy <TT>LCDRange</TT>), <A
href="lcdrange.cpp">lcdrange.cpp</A> (implementace metod tøídy
<TT>LCDRange</TT>) a <A href="main.cpp">main.cpp</A> (hlavní program
pou¾ívající tøídu <TT>LCDRange</TT>). Widget <TT>LCDRange</TT> se skládá ze
zobrazení èísla ve stylu LCD displeje (<TT>QLCDNumber</TT>) a z&nbsp;¹oupátka
<TT>QSlider</TT>, kterým se nastavuje zobrazená hodnota, viz obr. 1.

<DIV align="center">
<P><IMG alt="LCDRange" src="lcdrange.png">
<P>Obr. 1: Widget <TT>LCDRange</TT>
</DIV>

<P>Ná¹ nový widget obsahuje své dvì komponenty pod sebou, proto bude odvozen
z&nbsp;vertikálního boxu <TT>QVBox</TT> (funguje podobnì jako <TT>GtkVBox</TT>). Na
zaèátku souboru <TT>lcdrange.h</TT> musíme naèíst pøíslu¹ný hlavièkový soubor.
Ve tøídì <TT>LCDRange</TT> nebudeme potøebovat pøímo objekt <TT>QSlider</TT>,
ale pouze ukazatel na nìj. Proto staèí pouze deklarovat jméno tøídy. Tím, ¾e
se neincluduje hlavièkový soubor <TT>qslider.h</TT>, u¹etøíme èas pøi
pøekladu.
<PRE>
#include &lt;qvbox.h&gt;
class QSlider;
</PRE>

Aby Qt správnì rozpoznalo ná¹ widget jako nový typ, musíme na zaèátku tìla
tøídy pou¾ít makro <TT>Q_OBJECT</TT>. Tím se deklarují pomocné metody pro
typový systém Qt a zároveò se øekne, ¾e tento zdrojový soubor se bude
zpracovávat pomocí utility <TT>moc</TT>.
<PRE>
class LCDRange : public QVBox {
    Q_OBJECT
</PRE>

Následnì deklarujeme jednotlivé metody a datové polo¾ky tøídy, vèetnì signálù
a slotù. Sloty mù¾eme deklarovat jako <TT>public</TT>, <TT>protected</TT> nebo
<TT>private</TT>, signály jsou v¾dy <TT>protected</TT>. Makro <TT>slots</TT>
expanduje na prázdný øetìzec, makro <TT>signals</TT> má hodnotu
<TT>protected</TT>. Tato makra informují program <TT>moc</TT>, ¾e má urèité
metody o¹etøit speciálním zpùsobem, a zároveò zajistí, ¾e pøi pøekladu
dostaneme po prùchodu preprocesorem korektní zdrojový text v&nbsp;C++.
<PRE>
public:
    LCDRange(QWidget *parent = 0, const char *name = 0);
    int value() const;
public slots:
    void setValue(int);
signals:
    void valueChanged(int);
private:
    QSlider *slider;
};
</PRE>

<P>V souboru <TT>lcdrange.cpp</TT> definujeme jednotlivé metody. Konstruktor
vytvoøí dva synovské widgety &ndash; LCD èíslo a slider. Spojením signálu
<TT>valueChanged</TT> slideru se slotem <TT>display</TT> LCD èísla zajistíme
zmìnu zobrazené hodnoty pøi posunu slideru. Druhé volání <TT>connect</TT>
nastaví, ¾e signál <TT>QSlider::valueChanged</TT> zpùsobí vygenerování signálu
<TT>LCDRange::valueChanged</TT>. U¾ivatel na¹eho widgetu <TT>LCDRange</TT> 
má mo¾nost dozvìdìt se prostøednictvím tohoto signálu o&nbsp;zmìnì hodnoty. Nemusí
pøitom vùbec vìdìt, ¾e widget má ve skuteènosti dva synovské widgety a signál
pochází od jednoho z&nbsp;nich.
<PRE>
#include "lcdrange.h"
#include &lt;qslider.h&gt;
#include &lt;qlcdnumber.h&gt;

LCDRange::LCDRange(QWidget *parent, const char *name) : QVBox(parent, name)
{
    QLCDNumber *lcd = new QLCDNumber(2, this, "lcd");
    slider = new QSlider(Horizontal, this, "slider");
    slider-&gt;setRange(0, 99);
    slider-&gt;setValue(0);
    connect(slider, SIGNAL(valueChanged(int)), lcd, SLOT(display(int)));
    connect(slider, SIGNAL(valueChanged(int)), SIGNAL(valueChanged(int)));
}
</PRE>
Dál u¾ zbývá pouze implementovat metodu <TT>value</TT> a slot
<TT>setValue</TT>. Tìlo signálu <TT>valueChanged</TT> nedefinujeme. O&nbsp;správnou
definici, která bude volat pøipojené handlery, se postará program
<TT>moc</TT>.
<PRE>
int LCDRange::value() const
{
    return slider-&gt;value();
}

void LCDRange::setValue(int value)
{
    slider-&gt;setValue(value);
}
</PRE>

<P>Ka¾dý hlavièkový soubor, jen¾ obsahuje definici tøídy odvozené
z&nbsp;<TT>QObject</TT>, je nutné zpracovat pomocí nástroje </EM>Meta Object
Compiler</EM> (<TT>moc</TT>). Aby <TT>moc</TT> tøídu zpracoval, musí v&nbsp;ní být
pou¾ito makro <TT>Q_OBJECT</TT>. Dále mù¾e obsahovat deklarace signálù, slotù
a properties (hodnot pøístupných pomocí øetìzcového klíèe). Meta Object
Compiler vygeneruje pro ka¾dou tøídu <TT>XYZ</TT> soubor
<TT>moc_<EM>XYZ</EM>.cpp</TT>. V&nbsp;nìm jsou definice metod implementujících
signály a také definice <EM>meta-objektu</EM>. Ka¾dá tøída má svùj meta-objekt
typu <TT>QMetaObject</TT>, pøístupný prostøednictvím virtuální metody
<TT>QObject::metaObject</TT>. Meta-objekt popisuje vlastnosti tøídy: jméno
tøídy, jméno a odkaz na meta-objekt bázové tøídy, dále seznamy jmen a typù
slotù, signálù a properties. Informace z&nbsp;meta-objektu pou¾ívá napø. Qt
Designer nebo skriptovací engine QSA.

<H2>Postup pøi pøekladu programu</H2>

<P>Obr. 2 ukazuje, jak probíhá pøeklad programu, od zdrojových textù a¾
k&nbsp;výslednému spustitelnému souboru. Pøíklad vychází ze stejného ukázkového
programu, na jakém jsme si ukázali definici nové tøídy v&nbsp;první èásti èlánku.

<DIV align="center">
<P><IMG alt="pøeklad programu" src="make.png">
<P>Obr. 2: Postup pøekladu programu
</DIV>

<P>Na zaèátku máme v&nbsp;adresáøi pouze soubory se zdrojovými texty
(<TT>main.cc</TT>, <TT>lcdrange.h</TT>, <TT>lcdrange.cc</TT>). Pøíkaz
<PRE>
qmake -project
</PRE>
pro nì vytvoøí projektový soubor a dal¹í spu¹tìní <TT>qmake</TT> vygeneruje
<TT>Makefile</TT> obsahující pravidla pro volání kompilátoru, linkeru a Meta
Object Compileru. Pøíkaz <TT>make</TT> nejprve z&nbsp;hlavièkového souboru
<TT>lcdrange.h</TT> vytvoøí <TT>moc_lcdrange.cpp</TT> pomocí utility
<TT>moc</TT>. Pak u¾ se spustí kompilátor a linker.

<P>Alternativnì mù¾eme pou¾ít nástroj Qt Designer pro grafický návrh aplikace.
Designer vytváøí pro ka¾dý formuláø (tj. top-level okno) popis vzhledu okna
obsahující rozlo¾ení a vlastnosti widgetù. Definici formuláøe ukládá do
souboru <TT><EM>OKNO</EM>.ui</TT> ve formátu XML. Pøímo v&nbsp;designeru lze
definovat i chování widgetù tím, ¾e Qt Designer definuje pro ka¾dé okno
samostatnou tøídu a programátor doplní tìla jednotlivých slotù. Designer pak
definice slotù exportuje do souboru <TT><EM>OKNO</EM>.ui.h</TT>. Vygenerovat
se dá i standardní soubor <TT>main.cc</TT> s&nbsp;funkcí <TT>main</TT>, která
zobrazí hlavní okno a spustí zpracování událostí. Qt Designer vygeneruje také
projektový soubor pro <TT>qmake</TT>, v&nbsp;nìm¾ je øeèeno, ¾e
v&nbsp;<TT>Makefile</TT> má být volání utility <TT>uic</TT> (User Interface
Compiler). Ta z&nbsp;XML souboru <TT><EM>OKNO</EM>.ui</TT> vytvoøí soubory
<TT><EM>OKNO</EM>.h</TT> a <TT><EM>OKNO</EM>.cpp</TT>. Dal¹í postup je stejný
jako bez pou¾ití designeru. Na obr. 3 je pøíklad zalo¾ený na ukázkovém
programu z&nbsp;tutoriálu pro Qt Designer.

<DIV align="center">
<P><IMG alt="Qt Designer" src="designer.png">
<P>Obr. 3: Pøeklad aplikace vytvoøené v&nbsp;Qt Designeru
</DIV>

<H2>Automatické umís»ování widgetù</H2>

<P>Podobnì jako v&nbsp;GTK+, i v&nbsp;Qt se pozice a velikosti widgetù nastavují
automaticky. Ka¾dý widget má doporuèenou velikost, kterou vrací metoda
<TT>QWidget::sizeHint</TT>. Navíc má je¹tì metodu
<TT>QWidget::minimumSizeHint</TT> urèující minimální velikost widgetu. Metoda
<TT>QWidget::sizePolicy</TT> definuje, zda má widget v¾dy velikost
<TT>sizeHint</TT>, nebo se mù¾e zvìt¹ovat èi zmen¹ovat. Pøidìlování velikosti
probíhá podobnì jako v&nbsp;GTK+. Nejprve se prùchodem stromu widgetù zjistí
po¾adavky jednotlivých widgetù na velikost. U&nbsp;widgetu, jen¾ má potomky, závisí
jeho velikost na jeho vlastních potøebách a na po¾adavcích potomkù. Následnì
dostane top-level okno ve spolupráci s&nbsp;window managerem pøidìlené místo, které
se pak rozdìluje mezi potomky ve stromì widgetù.

<P>Nejjednodu¹¹í zpùsob, jak do rodièovského widgetu rozmístit synovské
widgety, je pou¾ití nìkterého <EM>layout widgetu</EM>. Vybírat lze ze tøí
typù: <TT>QHBox</TT> (synovské widgety seøazené v&nbsp;øádku zleva doprava),
<TT>QVBox</TT> (synovské widgety seøazené ve sloupci shora dolù) a
<TT>QGrid</TT> (synovské widgety ve dvojrozmìrné møí¾ce). Layout widgety
fungují podobnì jako v&nbsp;GTK+ kontejnery <TT>GtkHBox</TT>, <TT>GtkVBox</TT> a
<TT>GtkTable</TT>. V&nbsp;konstruktoru <TT>QGrid</TT> se zadává poèet sloupcù.
Jednotlivé synovské widgety se vkládají vedle sebe, po zaplnìní nastaveného
poètu sloupcù se pokraèuje v&nbsp;dal¹ím øádku. V¹echny tøi typy layout widgetù
jsou odvozené z&nbsp;<TT>QFrame</TT>, tak¾e umí kolem vlo¾ených widgetù kreslit
rámeèek. Kdy¾ potøebujeme nadefinovat slo¾itìj¹í rozlo¾ení widgetù, dají se
layout widgety vnoøovat. Na obr. 4 jsou v¹echny tøi typy layout widgetù.
Pøíslu¹ný zdrojový kód je <A href="layout_widgets.cpp">layout_widgets.cpp</A>.

<DIV align="center">
<P><IMG alt="layout widgety" src="layout_widgets.png">
<P>Obr. 4: Layout widgety <TT>QHBox</TT>, <TT>QVBox</TT> a <TT>QGrid</TT>
</DIV>

<P>Pokud potøebujeme vìt¹í kontrolu nad rozmístìním widgetù, mù¾eme pou¾ít
nìkterý z&nbsp;potomkù z&nbsp;tøídy <TT>QLayout</TT>. K&nbsp;dispozici jsou
<TT>QBoxLayout</TT>, <TT>QHBoxLayout</TT>, <TT>QVBoxLayout</TT> a
<TT>QGridLayout</TT>. Tyto layouty v¹ak nejsou widgety. Jsou to objekty, které
se vlo¾í do widgetu a øídí rozmístìní jeho synovských widgetù. V&nbsp;rámci jednoho
widgetu je mo¾né layouty vnoøovat. Pokud chceme do layoutu vlo¾it widget, je
tøeba ho vytvoøit tak, ¾e za rodièe bude mít widget, který je vlastníkem
layoutu. Následnì widget vlo¾íme do layoutu metodou <TT>add</TT> nebo
<TT>addWidget</TT>.

<PRE>
QHBoxLayout *box = new QHBoxLayout(parent);
box-&gt;addWidget(new QLabel("1", parent));
box-&gt;addWidget(new QLabel("2", parent));
</PRE>

Alternativnì mù¾eme nastavit voláním <TT>QLayout::setAutoAdd</TT>, ¾e v¹ichni
noví synové widgetu budou automaticky vlo¾eni do layoutu. Tato metoda v¹ak
funguje pouze pro top-level layout, tj. layout, jeho¾ rodièem je widget a
nikoliv jiný layout.

<PRE>
QHBoxLayout *box = new QHBoxLayout(widget);
box-&gt;setAutoAdd(TRUE);
new QLabel("1", widget);
new QLabel("2", widget);
</PRE>

Stejného vzhledu jako na obr. 4 lze s&nbsp;pou¾itím vnoøených layoutù místo layout
widgetù dosáhnout programem <A href="layouts.cpp">layouts.cpp</A>.

<H2>Kreslení</H2>

<P>Widget dostane událost <TT>QPaintEvent</TT>, jestli¾e je potøeba ho celý
nebo èást pøekreslit. Vlastní kreslení provádí handler
<TT>QWidget::paintEvent</TT>. Metoda <TT>QPaintEvent::region</TT> slou¾í ke
zji¹tìní oblasti, která se má kreslit. Zevnitø programu lze kreslení iniciovat
voláním <TT>QWidget::repaint</TT> nebo <TT>QWidget::update</TT>. Rozdíl mezi
nimi je v&nbsp;tom, ¾e <TT>repaint</TT> provede pøekreslení okam¾itì pøímým
zavoláním <TT>paintEvent</TT>, kde¾to <TT>update</TT> pouze vygeneruje událost
<TT>QPaintEvent</TT> a vlo¾í ji do fronty. Kreslení 2D grafiky se provádí
pomocí tøídy <TT>QPainter</TT>. Pro 3D grafiku je mo¾né pou¾ít knihovnu
OpenGL, pøístupnou prostøednictvím widgetu <TT>QGLWidget</TT>.

<P>Tøída <TT>QPainter</TT> kreslí do <TT>QPaintDevice</TT>, resp. do nìkterého
potomka této tøídy. Nejèastìji pou¾ívaný je widget (<TT>QWidget</TT>). Dal¹í
mo¾nosti jsou: pixmapa (<TT>QPixmap</TT>, rastrový obrázek), tiskárna
(<TT>QPrinter</TT>) a záznamník kreslících pøíkazù (<TT>QPicture</TT>). Objekt
tøídy <TT>QPicture</TT> si doká¾e zapamatovat posloupnost kreslicích operací
a následnì tyto operace zopakovat na nìjakém objektu <TT>QPainter</TT>.
Pøípadnì lze celou posloupnost ulo¾it do souboru v&nbsp;proprietárním formátu nebo
ve formátu SVG. 

<P>Ve tøídì <TT>QPainter</TT> jsou definovány funkce pro kreslení
geometrických tvarù (èar, polygonù, kruhù, obloukù a Beziérových køivek),
psaní textu a kreslení obrázkù (kopírování dat z&nbsp;<TT>QPixmap</TT>,
<TT>QImage</TT> nebo <TT>QPicture</TT>). Souøadnice se implicitnì mìøí
z&nbsp;levého horního rohu v&nbsp;pixelech doprava a dolù, ale soustavu souøadnic lze
transformovat pomocí operací posunu, rotace, zmìny mìøítka a zkosení.
Je také mo¾né pøímo nastavit transformaèní matici ve tvaru <IMG
src="matrix.png" alt="[m11 m12 0; m21 m22 0; dx dy 1]" align="center">. Matice
transformuje ka¾dý zadaný bod (x, y) na
(m<SUB>11</SUB>x+m<SUB>21</SUB>y+d<SUB>x</SUB>, 
m<SUB>12</SUB>x+m<SUB>22</SUB>y+d<SUB>y</SUB>). Ka¾dý objekt, který se má
nakreslit, je nejdøív transformován do souøadnic modelu pomocí transformaèní
matice, následnì se provede oøíznutí do obdélníku <TT>QPainter::window</TT> a
výsledek se umístí na <TT>QPaintDevice</TT> tak, ¾e <TT>window</TT>
(v&nbsp;souøadnicích modelu) se ztoto¾ní s&nbsp;obdélníkem <TT>QPainter::viewport</TT>
(v&nbsp;souøadnicích zaøízení). <TT>QPainter</TT> obsahuje také parametry kreslení,
jako je barva a tlou¹»ka èar, barva a vzorek pro vyplòování, nebo font.

<P>Typická metoda <TT>paintEvent</TT> vypadá tak, ¾e na zaèátku se vytvoøí
painter, nastaví se parametry, provedou se kreslicí operace a na konci se
painter automaticky zru¹í. Následující pøíklad, opìt pøevzatý z&nbsp;tutoriálu Qt,
nakreslí to, co je ve ¾lutém obdélníku na obr. 5.

<PRE>
void CannonField::paintEvent(QPaintEvent *)
{
    QPainter p(this);

    p.setBrush(blue);
    p.setPen(NoPen);

    p.translate(0, rect().bottom());
    p.drawPie(QRect(-35, -35, 70, 70), 0, 90 * 16);
    p.rotate(-ang);
    p.drawRect(QRect(33, -4, 15, 8));
}

<DIV align="center">
<P><IMG alt="pøíklad kreslení" src="drawing.png">
<P>Obr. 5: Pøíklad kreslení
</DIV>

</BODY>
</HTML>
